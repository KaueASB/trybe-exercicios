VOLUMES

Assim como aprendemos a utilizar volumes executando nossos containers de maneira individual, conseguimos tamb√©m utilizar volumes por meio do nosso arquivo compose.

Podemos definir nossos volumes da mesma maneira que fazemos com o comando docker container run, tanto como bind como da forma nomeada.

Podemos utilizar a forma mais extensa dele tamb√©m, por exemplo:

version: "3.8"
services:
  web:
    image: nginx:alpine
    volumes:
      - type: volume
        source: mydata
        target: /data
        volume:
          nocopy: true
      - type: bind
        source: ./static
        target: /opt/app/static

  db:
    image: postgres:latest
    volumes:
      - "/var/run/postgres/postgres.sock:/var/run/postgres/postgres.sock"
      - "dbdata:/var/lib/postgresql/data"

volumes:
  mydata:
  dbdata:

# ===============================================

NETWORKS

Conforme vimos na se√ß√£o Networks, nossos containers precisam estar na mesma rede para conseguir se comunicar utilizando o name.

Utilizando o Docker Compose, isso j√° √© realizado de maneira padr√£o. Ao iniciar um novo arquivo, ser√° criada uma rede padr√£o (bridge) para comunica√ß√£o de todos os servi√ßos especificados nele, dessa forma conseguimos facilmente comunicar todos os services de nosso ambiente. Quando executamos nosso arquivo de exemplo, voc√™ pode ter notado que o in√≠cio do log √© justamente a cria√ß√£o de uma rede padr√£o, algo similar a imagem a seguir:

CLI: docker-compose up

# inicio do log
Creating network "meu-site_default" with the default driver

Anota a√≠ üñä: Se apontarmos para o localhost:3000 simplesmente, nosso cont√™iner ir√° acessar a sua pr√≥pria porta 3000 e n√£o ir√° encontrar nada, pois o banco est√° em outro servi√ßo. Por isso, devemos sempre utilizar, caso o servi√ßo esteja em outro cont√™iner, o nome dele.

Caso fa√ßa sentido para nossa arquitetura, podemos ainda criar nossas pr√≥prias redes customizadas. Por exemplo, quando queremos isolar os servi√ßos.

Para isso, basta utilizar a op√ß√£o networks em nossos servi√ßos (services), definindo uma rede para um servi√ßo espec√≠fico e, ao final do arquivo, de forma semelhante ao volume, definimos as redes a serem criadas. A sintaxe b√°sica √© a seguinte:

version: "<VERS√ÉO-DO-COMPOSE>"
services:
  <MEU-CONTAINER-1>:
    image: <MINHA-IMAGEM:VERS√ÉO>
    networks:
      - <NETWORK-1>
    # ... outras configura√ß√µes
  <MEU-CONTAINER-2>:
    build: <CAMINHO-DO-DOCKERFILE>
    networks:
      - <NETWORK-1>
      - <NETWORK-1>
    # ... outras configura√ß√µes
  <MEU-CONTAINER-N>:
    image: <MINHA-IMAGEM:VERS√ÉO>
    # ... outras configura√ß√µes

networks:
  <NETWORK-1>:

Agora, vamos a um exemplo! Imagine que temos um ambiente com 3 services, sendo um front-end e dois back-ends, mais um banco de dados. Nessa arquitetura, apenas os back-ends acessam o banco de dados e o front-end acessa os back-ends. Para criarmos esses isolamentos, nosso YAML ficaria semelhante ao exemplo abaixo:

version: '3'

services:
  frontend-a:
    build: ./frontend_a
    networks:
      - frontend

  backend-a:
    build: ./backend_a
    networks:
      - backend
      - frontend

  backend-b:
    build: ./backend_b
    networks:
      - backend
      - frontend

  db:
    image: mysql
    networks:
      - backend

networks:
  frontend:
  backend:

# ===============================================
