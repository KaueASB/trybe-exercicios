version: "<VERS√ÉO-DO-COMPOSE>"
services: # Defini√ß√£o dos containers
  <MEU-CONTAINER-1>:
    image: <MINHA-IMAGEM:VERS√ÉO> # Exemplo carregando uma imagem j√° _buildada_
    # ... outras configura√ß√µes
  <MEU-CONTAINER-2>:
    build: <CAMINHO-DO-DOCKERFILE> # Exemplo gerando uma build a partir de um `Dockerfile`
    # ... outras configura√ß√µes
  <MEU-CONTAINER-N>:
    image: <MINHA-IMAGEM:VERS√ÉO>
    # ... outras configura√ß√µes

# ==============================================

VERSION

Todo arquivo docker-compose.yaml deve iniciar com a tag version. Desse modo, definimos qual vers√£o ser√° utilizada pelo compose para interpretar o arquivo, evitando que o docker-compose.yaml fique incompat√≠vel com vers√µes mais recentes do compose.
Voc√™ pode consultar as especifica√ß√µes de cada vers√£o em https://docs.docker.com/compose/compose-file/compose-versioning/#versioning.
Utilizaremos a vers√£o 3 do compose. Sendo assim, nosso yaml iniciar√° da seguinte maneira:

version: '3'

# ===============================================

SERVICES

S√£o os "tipos" dos cont√™ineres que iremos rodar. Por exemplo: se vamos executar uma API, dizemos que ela √© um service, porque com o Compose podemos escalar nossos apps em v√°rios cont√™ineres.
Podemos, por exemplo, escalar nossa API em 4 cont√™ineres diferentes, de forma que teremos um service que √© a nossa API, por√©m com 4 cont√™ineres em execu√ß√£o.
Dessa forma, ao escrevermos nosso arquivo, temos que pensar em services, pois √© assim que iremos defini-los.
Exemplo: Imagine que queremos subir uma aplica√ß√£o que cont√©m um front-end, um back-end e um banco de dados. Dessa forma, n√£o precisamos ainda pensar em quantos cont√™ineres, podemos dizer que temos 3 services. Para definir nossos services, utilizamos o par√¢metro services.
Vamos ver como ficaria esse exemplo em nosso arquivo Compose:

version: '3'
services:
  frontend::

  backend:

  database:

Perceba no exemplo acima que demos um nome aos nosso servi√ßos, por√©m n√£o especificamos o que dever√° ser executado.
Relembrandoüß†: Todo cont√™iner √© criado a partir de uma imagem, sendo assim, precisamos especific√°-las aos nossos servi√ßos. Para isso, podemos utilizar dois comandos:

- image para especificar uma imagem, seja local ou a ser baixada no Docker Hub;
- build para apontar um diret√≥rio com o Dockerfile a partir do qual o Compose ir√° buildar a imagem para n√≥s.


No exemplo a seguir, construiremos as tr√™s partes da aplica√ß√£o a partir dessas imagens dispon√≠veis no Docker Hub (https://hub.docker.com/r/mjgargani/compose-example/tags). Portanto, usaremos sempre o comando image para especificar cada uma delas. Nosso docker-compose.yaml ficaria assim:

version: '3'
services:
  frontend:
    image: mjgargani/compose-example:frontend-trybe1.0
  backend:
    image: mjgargani/compose-example:backend-trybe1.0
  database:
    image: mjgargani/compose-example:database-trybe1.0

Nosso arquivo ir√° funcionar como se estiv√©ssemos executando tr√™s docker container run, um para cada servi√ßo. Sendo assim, precisamos definir os demais par√¢metros para os nossos cont√™ineres.

#  ===============================================

RESTART

No Docker existem as pol√≠ticas de reinicializa√ß√£o, que servem para gerenciar se nossos cont√™ineres reiniciar√£o automaticamente quando o Docker for reiniciado ou quando ocorrer algum erro, por exemplo.
Este comando pode assumir quatro valores:
- no: Este √© o valor padr√£o assumido pelo Docker e define que o container n√£o ir√° restartar automaticamente;

- on-failure: Define que o container ser√° reiniciado caso ocorra alguma falha, apontado pelo exit code diferente de zero;

- always: Especifica que sempre que o servi√ßo parar, seja por um falha ou porque ele finalizou sua execu√ß√£o, ele ir√° ser reiniciado;
  Caso o cont√™iner seja interrompido manualmente, ele s√≥ ser√° reiniciado depois que o daemon do Docker for reiniciado ou que o pr√≥prio cont√™iner seja reiniciado manualmente. Esse √© um mecanismo pra evitar loops.

- unless-stopped: Define que o cont√™iner sempre seja reiniciado, a menos que o Docker em si seja parado (manualmente ou n√£o). No caso de ser interrompido, ele n√£o reinicia nem se o daemon do Docker for reiniciado.
  O daemon do Docker √© um processo cont√≠nuo e que roda em segundo plano, gerenciando os cont√™ineres Docker em um host.

‚ö†Ô∏è Aviso: √â importante utilizarmos o par√¢metro em ambiente de produ√ß√£o, principalmente quando utilizarmos o Docker Compose, conforme √© recomendado pelas especifica√ß√µes da pr√≥pria documenta√ß√£o.
Com a adi√ß√£o dessa configura√ß√£o, nosso exemplo ficar√° assim:

version: '3'
services:
  frontend:
    image: mjgargani/compose-example:frontend-trybe1.0
    restart: always
  backend:
    image: mjgargani/compose-example:backend-trybe1.0
    restart: always
  database:
    image: mjgargani/compose-example:database-trybe1.0
    restart: always

# ============================================================

PORTS

No docker-compose.yaml temos o par√¢metro ports que se comporta da mesma maneira que o -p do docker container run.
No exemplo abaixo, queremos utilizar a porta 3000 para nosso front-end e a porta 3001 para nosso back-end, ambas fazendo bind para as respectivas portas no host. Dessa forma, nosso arquivo ficar√° assim:

version: '3'
services:
  frontend:
    image: mjgargani/compose-example:frontend-trybe1.0
    restart: always
    ports:
      - 3000:3000
  backend:
    image: mjgargani/compose-example:backend-trybe1.0
    restart: always
    ports:
      - 3001:3001
  database:
    image: mjgargani/compose-example:database-trybe1.0
    restart: always

Anota a√≠ üñä: O primeiro par√¢metro √© a porta do host(sua m√°quina) e o segundo a porta exposta no cont√™iner.

# =============================================================

ENVIRONMENT

Outro par√¢metro importante √© o environment. Com ele, conseguimos configurar as vari√°veis de ambiente de nossos cont√™ineres.
Imagine que precisamos passar para nosso back-end uma parte da URL onde o banco de dados ir√° rodar, em uma vari√°vel chamada DB_HOST. Nosso exemplo ficaria assim:

version: '3'
services:
  frontend:
    image: mjgargani/compose-example:frontend-trybe1.0
    restart: always
    ports:
      - 3000:3000
  backend:
    image: mjgargani/compose-example:backend-trybe1.0
    restart: always
    ports:
      - 3001:3001
    environment:
      - DB_HOST=database
  database:
    image: mjgargani/compose-example:database-trybe1.0
    restart: always

Perceba que estamos passando a vari√°vel DB_HOST, que est√° em nosso host, para a vari√°vel "DBHOST" do _cont√™iner, onde o back-end est√° esperando por ela.
  Lembre-se que mesmo tendo a env configurada em seu ambiente, ela s√≥ ser√° passada ao cont√™iner se especificada aqui, da mesma maneira como fazemos com o par√¢metro -e ou --env no comando run.

Aqui tamb√©m √© poss√≠vel utilizarmos vari√°veis de ambiente. Por exemplo, imagine que temos uma vari√°vel API_SECRET com uma secret. Por se tratar de um dado sens√≠vel, n√£o podemos coloc√°-lo em um arquivo a ser versionado como parte de nossa aplica√ß√£o, por√©m ainda temos que especificar ao Compose qual vari√°vel ir√° ser passada para qual cont√™iner.

‚ö†Ô∏è Aviso: No contexto de Docker, secret √© um dado que n√£o deve ser transmitido por uma rede ou armazenado sem criptografia em um Dockerfile ou at√© mesmo no c√≥digo fonte de sua aplica√ß√£o, como uma senha ou uma chave privada SSH, por exemplo.

Voc√™ pode dar uma olhada mais aprofundada em vari√°veis de ambiente usando docker-compose nesse link. (https://docs.docker.com/compose/environment-variables/)

# =============================================================

DEPENDS ON

Outro par√¢metro importante para garantir a ordem de inicializa√ß√£o e encerramento de services √© o depends_on. Com ele, conseguimos estabelecer depend√™ncias entre os servi√ßos.
Para entendermos mais detalhadamente os comportamentos dessa flag, vamos voltar para a aplica√ß√£o que est√°vamos construindo como exemplo:

version: "3"
services:
  frontend:
    image: mjgargani/compose-example:frontend-trybe1.0
    restart: always
    ports:
      - 3000:3000
    depends_on:
      - "backend"
  backend:
    image: mjgargani/compose-example:backend-trybe1.0
    restart: always
    ports:
      - 3001:3001
    environment:
      - DB_HOST=database
    depends_on:
      - "database"
  database:
    image: mjgargani/compose-example:database-trybe1.0
    restart: always

Nesse exemplo, os services ser√£o iniciados respeitando a ordem das depend√™ncias, portanto, o database ser√° iniciado antes do backend, que ser√° startado antes do frontend.